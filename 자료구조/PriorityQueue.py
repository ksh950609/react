# 우선순위 큐 
# 우선순위 큐는 우선순위가 가장 높은 데이터를 가장 먼저 삭제하는 자료구조
# 우선순위 큐는 데이터를 우선순위에 따라 처리하고 싶을 떄 사용함
# 물건 데이터를 자료구조에 넣었다가 가치가 높은 물건부터 꺼내서 확인하는 경우 

# 스택 : 가장 나중에 삽입된 데이터
# 큐   : 가장 먼저 삽입된 데이터
# 우선순위 큐 : 가장 우선순위가 높은 데이터

# 우선순위 큐를 구현하는 방법 
# 1) 단순하게 리스트를 이용하여 구현할 수 있다
# 2) 힙을 이용하여 구현한다.
# 데이터의 개수가 N개일 떄, 구현 방식에 따라서 시간 복잡도를 비교한 내룡은 이렇다
# 우선순위 큐 구현 방식     삽입시간    삭제시간
#   리스트                  O(1)        O(N)
#   힙                      O(logN)     O(logN)

# 단순하게 N개의 데이터를 힙에 넣었다가 모두 꺼내는 작업은 정렬과 동일하다
# 이 경우 시간복잡도는 O(NlogN)


# 립은 완전 이진 트리 자료구조의 일종
# 힙에서는 항상 루트노드를 제거합니다.

# 최소 힙
# 루트 노드가 가장 작은 값을 가집니다
# 따라서 값이 작은 데이터가 우석ㄴ적으로 제거됩니다.

# 최대 힙 
# 루트 노드가 가장 큰값을 가집니다
# 따라서 값이 큰 데이터가 우선적으로 제거됩니다.

# 완전 이진 트리 (complete binary Tree)
# 완전 이진트리란 루트노드부터 시작하여 왼쪽 자식 노드 , 오른쪽 자식 노드 순서대로 데이터가 차례대로 삽입되는 트리다


#최소 힙 수정 함수 (MIN - Heapify())
#상향식 부모 노드로 거슬러 올라가며, 부모보다 자신의 값이 더 작은 경우에 위치를 교체합니다.

# 3- 5- 4-6      -> 3-4-5-6

#새로운 원소가 삽입되었을 떄  O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있습니다. 

# 균형 잡힌 트리

# 힙에서 원소가 제거될 떄 
# 원소가 제거되었을 떄 O(logN)의 시간 복잡도로 힙 성질을 유지하도록 할 수 있습니다 
# 원소를 제거할 떄는 가장 마지막 노드가 루트 노드의 위치에 오도록 한다.


import sys
import heapq
input = sys.stdin.readline

def heapsort(iterable):
    h = []
    result = []
    # 모든 원소를 차례대로 립에 삽입
    for value in iterable :
        heapq.heappush(h, value)
        # 힙에 삽입된 모든 원소를 차례대로 꺼내어 담기
        for i in range(len(h)):
            result.append(heapq.heappop(h))
            return result
    
    n = int(input())
    arr = []
    
    for i in range(n):
        arr.append(int(input()))
        
        res = heapsort(arr)
        print(res[i])